# -*- python -*-
# ex: set syntax=python:

from buildbot.buildslave import BuildSlave
from buildbot.process.factory import BuildFactory
from buildbot.config import BuilderConfig
from buildbot.schedulers.basic import SingleBranchScheduler
from buildbot.schedulers.forcesched import *
from buildbot.changes import filter
from buildbot.steps.source.git import Git
from buildbot.steps.shell import ShellCommand, SetPropertyFromCommand
from buildbot.steps.transfer import DirectoryUpload, FileDownload, FileUpload, StringDownload
from buildbot.steps.slave import SetPropertiesFromEnv
from buildbot.steps.master import MasterShellCommand
from buildbot.process.properties import Interpolate, Property, renderer
from buildbot.process.builder import enforceChosenSlave
from twisted.internet import defer
import buildbot.status.html as html
import buildbot.status.web.authz as authz
import os
import os.path
import hashlib
import hmac
import itsdangerous

# useful constants
DEFAULT_REPOSITORY = "https://github.com/overviewer/Minecraft-Overviewer"

# confidentials
POSTGRES_PASSWORD = os.environ['POSTGRES_PASSWORD']
BUILDBOT_SECRET = os.environ['BUILDBOT_SECRET']
FLASK_SECRET = os.environ['FLASK_SECRET']

def gen_pw(name):
    return hmac.new(BUILDBOT_SECRET, name, hashlib.sha512).hexdigest()

# our config object
c = BuildmasterConfig = {}

c['title'] = "Minecraft Overviewer"
c['titleURL'] = "http://diax.overviewer.org/"

c['protocols'] = {'pb': {'port': 9989}}

class OverviewerAuthz(authz.Authz):
    flask_signer = itsdangerous.URLSafeTimedSerializer(
        FLASK_SECRET,
        salt='cookie-session',
        signer_kwargs=dict(
            key_derivation='hmac',
            digest_method=hashlib.sha1,
        ),
    )

    def __init__(self, default_action=False, httpLoginUrl=False, **kwargs):
        super(OverviewerAuthz, self).__init__(default_action=default_action, auth=None, useHttpHeader=True, httpLoginUrl=httpLoginUrl, **kwargs)
    
    def get_flask_session(self, request):
        try:
            return request._flask_session
        except AttributeError:
            pass

        session = request.received_cookies.get('session', None)
        if not session:
            request._flask_session = None
            return None
        try:
            # attempt to decode session
            s = self.flask_signer.loads(session)
            request._flask_session = s
            return s
        except Exception:
            request._flask_session = None
            return None

    def authenticated(self, request):
        s = self.get_flask_session(request)
        if s and s.get('logged_in') and s.get('developer'):
            return True
        return False

    def getUsername(self, request):
        s = self.get_flask_session(request)
        if s and s.get('logged_in') and s.get('user'):
            return s['user']
        return '<unknown>'

    def getUsernameHTML(self, request):
        s = self.get_flask_session(request)
        if s and s.get('logged_in') and s.get('user'):
            return '<a href="https://github.com/%s">%s</a>' % (s['user'], s['user'])
        return '&lt;unknown&gt;'

    def getUsernameFull(self, request):
        return self.getUsername(request)

    def getPassword(self, request):
        return '<no-password>'

    def actionAllowed(self, action, request, *args):
        if action not in self.knownActions:
            raise KeyError("unknown action")
        cfg = self.config.get(action, False)
        if cfg:
            if cfg == 'auth' or callable(cfg):
                if not self.authenticated(request):
                    return defer.succeed(False)
                if callable(cfg) and not cfg(self.getUsername(request), *args):
                    return defer.succeed(False)
                return defer.succeed(True)
        return defer.succeed(cfg)

    def login(self, request):
        pass

    def logout(self, request):
        pass

authz_cfg = OverviewerAuthz(
    httpLoginUrl="http://diax.overviewer.org/login?next=/build/",
    gracefulShutdown = False,
    forceBuild = 'auth',
    forceAllBuilds = 'auth',
    pingBuilder = 'auth',
    stopBuild = 'auth',
    stopAllBuilds = 'auth',
    cancelPendingBuild = 'auth',
)

c['buildbotURL'] = 'http://diax.overviewer.org/build/'
c['status'] = [
    html.WebStatus(
        http_port=8010,
        authz=authz_cfg,
        change_hook_dialects={'github': True},
    ),
]

c['db'] = {
    'db_url': 'postgresql://postgres:' + POSTGRES_PASSWORD + '@postgres/bbmaster',
}

# high-level slave list
# slaves[name] = [... list of builders ...]
slaves = {
    'diax_wheezy64': ['src', 'deb64'],
}

# all the builds that should fire automatically
ALL_BUILDERS = ['src']

c['slaves'] = []
builders_to_slaves = {}
for name, builders in slaves.items():
    c['slaves'].append(BuildSlave(name, gen_pw(name)))
    for builder in builders:
        builders_to_slaves.setdefault(builder, list()).append(name)

c['schedulers'] = [
    SingleBranchScheduler(
        name='Overviewer Master Scheduler',
        change_filter=filter.ChangeFilter(branch='master'),
        treeStableTimer=None,
        builderNames=ALL_BUILDERS,
    ),
    ForceScheduler(
        name="Overviewer Force Scheduler",
        branch=StringParameter(name="branch", default="master"),
        repository=StringParameter(name="repository", default=DEFAULT_REPOSITORY, size=80),
        project=FixedParameter(name="project", choices=["overviewer"], default="overviewer"),
        properties=[BuildslaveChoiceParameter()],
        builderNames=ALL_BUILDERS,
    ),
]

c['builders'] = []

# high-level builder maker
# @builder(builder_config_key=...)
# def src():
#     yield BuildStep, {kwargs}
def builder(**configExtra):
    def wrapper(f):
        name = f.__name__
        factory = BuildFactory()
        for stepcls, kwargs in f():
            stepargs = dict(
                haltOnFailure = True,
            )
            stepargs.update(kwargs)
            factory.addStep(stepcls(**stepargs))
        
        config = dict(
            name = name,
            canStartBuild=enforceChosenSlave,
            slavenames=builders_to_slaves.get(name, []),
            factory = factory,
        )
        config.update(configExtra)
        builder = BuilderConfig(**config)
        c['builders'].append(builder)
        return builder
    return wrapper

def extract_stdout(key):
    def extract(rc, stdout, stderr):
        return {key: stdout.strip()}
    return extract

def upload_dest(fext):
    def _masterdest(props):
        project = props.getProperty('project')
        version = props.getProperty('version')
        builder = props.getProperty('buildername')
        buildnum = props.getProperty('buildnumber')
        revision = props.getProperty('got_revision')
        if any(x is None for x in [project, version, builder, buildnum, revision]):
            raise RuntimeError("need project, version, buildername, buildnumber, and got_revision properties set")
        revision = revision[:7]
        basename = '%s-%s-%s.%s-%s%s' % (project, version, builder, buildnum, revision, fext)
        return os.path.join("/data/buildbot/uploads", basename)
    return renderer(_masterdest)

def upload_url(fext):
    return Interpolate("http://diax.overviewer.org/builds/%(prop:buildername)s/%(prop:buildnumber)s/%(prop:project)s-%(prop:version)s" + fext)

@builder()
def src():
    yield Git, dict(repourl=Property('repository'), mode='full', method='fresh', name='checkout')
    yield SetPropertyFromCommand, dict(command=["python2", "setup.py", "--version"], extract_fn=extract_stdout('version'), name="get version")
    yield ShellCommand, dict(command=["python2", "setup.py", "sdist"], name="sdist")
    yield FileUpload, dict(slavesrc=Interpolate("dist/Minecraft-Overviewer-%(prop:version)s.tar.gz"), masterdest=upload_dest('.tar.gz'), url=upload_url('.tar.gz'), name="upload")
