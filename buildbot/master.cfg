# -*- python -*-
# ex: set syntax=python:

from buildbot.buildslave import BuildSlave
from buildbot.process.factory import BuildFactory
from buildbot.config import BuilderConfig
from buildbot.schedulers.basic import SingleBranchScheduler
from buildbot.schedulers.forcesched import *
from buildbot.changes import filter
from buildbot.steps.source.git import Git
from buildbot.steps.shell import ShellCommand, SetPropertyFromCommand
from buildbot.steps.transfer import DirectoryUpload, FileDownload, FileUpload, StringDownload
from buildbot.steps.slave import SetPropertiesFromEnv
from buildbot.steps.master import MasterShellCommand
from buildbot.process.properties import Interpolate, Property, renderer
from buildbot.process.builder import enforceChosenSlave
from buildbot import locks
from twisted.internet import defer
import buildbot.status.html as html
import buildbot.status.web.authz as authz
import os
import os.path
import hashlib
import time
import hmac
import itsdangerous

# useful constants
DEFAULT_REPOSITORY = "https://github.com/overviewer/Minecraft-Overviewer"
DEFAULT_CLIENT_JAR_VER = "1.8"
DEBIAN_REPO = "/data/buildbot/repos/debian"

# confidentials
POSTGRES_PASSWORD = os.environ['POSTGRES_PASSWORD']
BUILDBOT_SECRET = os.environ['BUILDBOT_SECRET']
FLASK_SECRET = os.environ['FLASK_SECRET']

# don't leak secrets, only leave whitelisted envs
for k in list(os.environ.keys()):
    if not k in ['PATH', 'PWD', 'SHLVL', 'GPG_AGENT_INFO']:
        del os.environ[k]

def gen_pw(name):
    return hmac.new(BUILDBOT_SECRET, name, hashlib.sha512).hexdigest()

# our config object
c = BuildmasterConfig = {}

c['title'] = "Minecraft Overviewer"
c['titleURL'] = "http://diax.overviewer.org/"

c['protocols'] = {'pb': {'port': 9989}}

class OverviewerAuthz(authz.Authz):
    flask_signer = itsdangerous.URLSafeTimedSerializer(
        FLASK_SECRET,
        salt='cookie-session',
        signer_kwargs=dict(
            key_derivation='hmac',
            digest_method=hashlib.sha1,
        ),
    )

    def __init__(self, default_action=False, httpLoginUrl=False, **kwargs):
        super(OverviewerAuthz, self).__init__(default_action=default_action, auth=None, useHttpHeader=True, httpLoginUrl=httpLoginUrl, **kwargs)
    
    def get_flask_session(self, request):
        try:
            return request._flask_session
        except AttributeError:
            pass

        session = request.received_cookies.get('session', None)
        if not session:
            request._flask_session = None
            return None
        try:
            # attempt to decode session
            s = self.flask_signer.loads(session)
            request._flask_session = s
            return s
        except Exception:
            request._flask_session = None
            return None

    def authenticated(self, request):
        s = self.get_flask_session(request)
        if s and s.get('logged_in') and s.get('developer'):
            return True
        return False

    def getUsername(self, request):
        s = self.get_flask_session(request)
        if s and s.get('logged_in') and s.get('user'):
            return s['user']
        return '<unknown>'

    def getUsernameHTML(self, request):
        s = self.get_flask_session(request)
        if s and s.get('logged_in') and s.get('user'):
            return '<a href="https://github.com/%s">%s</a>' % (s['user'], s['user'])
        return '&lt;unknown&gt;'

    def getUsernameFull(self, request):
        return self.getUsername(request)

    def getPassword(self, request):
        return '<no-password>'

    def actionAllowed(self, action, request, *args):
        if action not in self.knownActions:
            raise KeyError("unknown action")
        cfg = self.config.get(action, False)
        if cfg:
            if cfg == 'auth' or callable(cfg):
                if not self.authenticated(request):
                    return defer.succeed(False)
                if callable(cfg) and not cfg(self.getUsername(request), *args):
                    return defer.succeed(False)
                return defer.succeed(True)
        return defer.succeed(cfg)

    def login(self, request):
        pass

    def logout(self, request):
        pass

authz_cfg = OverviewerAuthz(
    httpLoginUrl="http://diax.overviewer.org/login?next=/build/",
    gracefulShutdown = False,
    forceBuild = 'auth',
    forceAllBuilds = 'auth',
    pingBuilder = 'auth',
    stopBuild = 'auth',
    stopAllBuilds = 'auth',
    cancelPendingBuild = 'auth',
)

c['buildbotURL'] = 'http://diax.overviewer.org/build/'
c['status'] = [
    html.WebStatus(
        http_port=8010,
        authz=authz_cfg,
        change_hook_dialects={'github': True},
    ),
]

c['db'] = {
    'db_url': 'postgresql://postgres:' + POSTGRES_PASSWORD + '@postgres/bbmaster',
}

# high-level slave list
# slaves[name] = [... list of builders ...]
slaves = {
    'diax-wheezy-64': ['src', 'deb64'],
    'diax-fc21-64': ['src', 'el5-32', 'el5-64', 'el6-32', 'el6-64', 'fc19-32', 'fc19-64'],
}

# all the builds that should fire automatically
ALL_BUILDERS = ['src', 'deb64', 'el5-32', 'el5-64', 'el6-32', 'el6-64', 'fc19-32', 'fc19-64']

c['slaves'] = []
builders_to_slaves = {}
for name, builders in slaves.items():
    c['slaves'].append(BuildSlave(name, gen_pw(name)))
    for builder in builders:
        builders_to_slaves.setdefault(builder, list()).append(name)

c['schedulers'] = [
    SingleBranchScheduler(
        name='Overviewer Master Scheduler',
        change_filter=filter.ChangeFilter(branch='master'),
        treeStableTimer=None,
        builderNames=ALL_BUILDERS,
    ),
    ForceScheduler(
        name="Overviewer Force Scheduler",
        branch=StringParameter(name="branch", default="master"),
        repository=StringParameter(name="repository", default=DEFAULT_REPOSITORY, size=80),
        project=FixedParameter(name="project", choices=["overviewer"], default="overviewer"),
        properties=[BuildslaveChoiceParameter()],
        builderNames=ALL_BUILDERS,
    ),
]

c['builders'] = []

# high-level builder maker
# @builder(builder_config_key=...)
# def src():
#     yield BuildStep, {kwargs}
def builder(**configExtra):
    def wrapper(f):
        name = f.__name__.replace('_', '-')
        factory = BuildFactory()
        def runstep(step):
            try:
                steps = iter(step)
                for step in steps:
                    runstep(step)
            except TypeError:
                info = step._factory
                stepkwargs = dict(
                    haltOnFailure = True,
                )
                stepkwargs.update(info.kwargs)
                step = info.factory(*info.args, **stepkwargs)
                factory.addStep(step)

        runstep(f())
        
        config = dict(
            name = name,
            canStartBuild=enforceChosenSlave,
            slavenames=builders_to_slaves.get(name, []),
            factory = factory,
        )
        config.update(configExtra)
        builder = BuilderConfig(**config)
        c['builders'].append(builder)
        return f
    return wrapper

def is_release_build(step):
    "Only if we're building on the official repo's master branch"
    return step.build.getProperty("branch", "") == "master" and step.build.getProperty("repository", "") == DEFAULT_REPOSITORY

def extract_stdout(key):
    def extract(rc, stdout, stderr):
        return {key: stdout.strip()}
    return extract

def upload_dest(fext):
    def _masterdest(props):
        project = props.getProperty('project')
        version = props.getProperty('version')
        builder = props.getProperty('buildername')
        buildnum = props.getProperty('buildnumber')
        revision = props.getProperty('got_revision')
        if any(x is None for x in [project, version, builder, buildnum, revision]):
            raise RuntimeError("need project, version, buildername, buildnumber, and got_revision properties set")
        revision = revision[:7]
        basename = '%s-%s-%s.%s-%s%s' % (project, version, builder, buildnum, revision, fext)
        return os.path.join("/data/buildbot/uploads", basename)
    return renderer(_masterdest)

def upload_url(fext):
    return Interpolate("http://diax.overviewer.org/builds/%(prop:buildername)s/%(prop:buildnumber)s/%(prop:project)s-%(prop:version)s" + fext)

def checkout(workdir=None):
    yield Git(repourl=Property('repository'), mode='full', method='fresh', name='checkout', workdir=workdir)
    yield SetPropertyFromCommand(command=["python2", "setup.py", "--version"], extract_fn=extract_stdout('version'), name="get version", workdir=workdir)
    yield SetPropertyFromCommand(command=["git", "describe", "--tags"], extract_fn=extract_stdout('desc'), name="get desc", workdir=workdir)

def upload(src, fext, **kwargs):
    yield FileUpload(slavesrc=src, masterdest=upload_dest(fext), url=upload_url(fext), name="upload", mode=0644, **kwargs)

@builder()
def src():
    yield checkout()
    yield ShellCommand(command=["python2", "setup.py", "sdist"], name="sdist")
    yield upload(Interpolate("dist/Minecraft-Overviewer-%(prop:version)s.tar.gz"), ".tar.gz")

@renderer
def debian_build_changelog(props):
    version = props.getProperty("version")
    desc = props.getProperty("desc")
    now = time.strftime("%a, %d %b %Y %H:%M:%S +0000", time.gmtime())
    s = """minecraft-overviewer (%s-0~overviewer1) unstable; urgency=low

  * Automatically generated from Git: %s

 -- Aaron Griffith <agrif@overviewer.org>  %s""" % (version, desc, now)
    return s

deb_repo_lock = locks.MasterLock("deb_repo_lock")
def debian():
    yield checkout()
    yield ShellCommand(command=["python", "setup.py", "build"], name="build")

    # move and untar our control files
    yield FileDownload(mastersrc="debian.tar", slavedest="debian/all.tar", name="transfer control files")
    yield ShellCommand(command=["tar", "--no-same-owner", "-xf", "all.tar"], workdir="build/debian", name="untar control files")

    # note all.tar does not contain the changelog, it's generated here
    yield StringDownload(debian_build_changelog, slavedest="debian/changelog", name="create changelog")

    # build and upload
    yield ShellCommand(command=['debuild', '-i', '-us', '-uc', '-b'], name="deb build")
    yield SetPropertyFromCommand(command="ls -1 *.deb", workdir=".", property="debfile", name="get deb filename")
    yield upload(Property("debfile"), ".deb", workdir="")
    yield ShellCommand(command="rm -f *.deb *.changes *.build", workdir=".", name="clean up built files")

    # sign the uploaded package
    # note the argument to -g is *intentionally* one string
    yield MasterShellCommand(command=["dpkg-sig", "-g", "--use-agent --batch --no-tty", "--sign", "builder", upload_dest(".deb")], name="sign package", description="signing", descriptionDone="signed")

    # repo nonsense, use symlinks
    yield MasterShellCommand(command=["ln", "-f", upload_dest(".deb"), DEBIAN_REPO + "/files/"], name="link into repo", doStepIf=is_release_build, description="linking to repo", descriptionDone="linked to repo")
    yield MasterShellCommand(command=["make", "-C", DEBIAN_REPO], name="rebuild repo", doStepIf=is_release_build, locks=[deb_repo_lock.access('exclusive')], description="rebuilding repo", descriptionDone="rebuilt repo")

@builder()
def deb64():
    yield debian()

rpm_build_lock = locks.SlaveLock("rpm_build_lock", maxCount=1)
rpm_repo_lock = locks.MasterLock("rpm_repo_lock")

def rpm(rpmbase, mockbase, mockconfig, rpmarch, mockarch):
    yield checkout(workdir="build/Minecraft-Overviewer")

    # move and untar our control files
    yield FileDownload(mastersrc="rpm.tar", slavedest="rpm/all.tar", name="transfer control files")
    yield ShellCommand(command=["tar", "--no-same-owner", "-xf", "all.tar"], workdir="build/rpm", name="untar control files")

    # build source tarball
    yield SetPropertiesFromEnv(variables=["HOME"])
    yield ShellCommand(command=["mkdir", "-p", Interpolate("%(prop:HOME)s/rpmbuild/SOURCES/")], workdir="build", name="ensure SOURCES exists")
    yield ShellCommand(command=["tar", "-czf", Interpolate("%(prop:HOME)s/rpmbuild/SOURCES/Minecraft-Overviewer-%(prop:version)s.tar.gz"), "Minecraft-Overviewer"], workdir="build", name="create source tarball")

    # replace {VERSION} string in spec file
    yield ShellCommand(command=['sed', '-i', Interpolate('s/{VERSION}/%(prop:version)s/'), "rpm/" + rpmbase + "/Minecraft-Overviewer.spec"], name="replace version in spec file")

    # build source RPM
    if rpmbase == "el5":
        yield ShellCommand(command=['rpmbuild', '-bs', '--define', 'dist .' + rpmbase, '--define', '_source_filedigest_algorithm md5', 'rpm/' + rpmbase + '/Minecraft-Overviewer.spec'], name='create source rpm')
    else:
        yield ShellCommand(command=['rpmbuild', '-bs', '--define', 'dist .' + rpmbase, 'rpm/' + rpmbase + '/Minecraft-Overviewer.spec'], name="create source rpm")

    # build RPM
    srpm = Interpolate("%(prop:HOME)s/rpmbuild/SRPMS/Minecraft-Overviewer-%(prop:version)s-1." + rpmbase + ".src.rpm")
    yield ShellCommand(command=['/usr/bin/mock', '-r', mockconfig + '-' + rpmarch, srpm], name="build RPM")

    # upload
    yield upload(Interpolate('/var/lib/mock/' + mockconfig + '-' + rpmarch + '/result/Minecraft-Overviewer-%(prop:version)s-1.' + mockbase + '.' + mockarch + '.rpm'), '.rpm')
    yield ShellCommand(command="rm -rf rpm", workdir="build", name="clean up control files")

    # link the new rpm into the repo
    # FIXME

@builder(locks=[rpm_build_lock.access('exclusive')])
def fc19_64():
    yield rpm('fc19', 'fc19', 'fedora-19', 'x86_64', 'x86_64')

@builder(locks=[rpm_build_lock.access('exclusive')])
def el6_64():
    yield rpm('el6', 'el6', 'epel-6', 'x86_64', 'x86_64')

@builder(locks=[rpm_build_lock.access('exclusive')])
def el5_64():
    yield rpm('el5', 'el5.centos', 'epel-5', 'x86_64', 'x86_64')

@builder(locks=[rpm_build_lock.access('exclusive')])
def fc19_32():
    yield rpm('fc19', 'fc19', 'fedora-19', 'i386', 'i686')

@builder(locks=[rpm_build_lock.access('exclusive')])
def el6_32():
    yield rpm('el6', 'el6', 'epel-6', 'i386', 'i686')

@builder(locks=[rpm_build_lock.access('exclusive')])
def el5_32():
    yield rpm('el5', 'el5.centos', 'epel-5', 'i386', 'i386') # Probably unique on purpose

